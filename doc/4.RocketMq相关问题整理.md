# 4. RocketMq相关问题整理

#### 1. Rocketmq可以实现队列的优先级么? 

>由于 RocketMQ 所有消息都是持久化的，所以如果按照优先级来排序，开销会非常大，因此 **RocketMQ 没有特意支持消息优先级**，但是可以通过变通的方式实现类似功能，即单独配置一个优先级高的队列，和一个普通优先级 的队列， 将不同优先级发送到不同队列即可。

#### 2. RocketMq消息的可靠性如何? 

>| 影响情况                         | 同步刷盘     | 异步刷盘     | 恢复情况   |
>| -------------------------------- | ------------ | ------------ | ---------- |
>| Broker正常关闭                   | 不丢失       | 丢失少量数据 | 可立即恢复 |
>| Broker异常Crash                  | 不丢失       | 丢失少量数据 | 可立即恢复 |
>| OS Crash                         | 不丢失       | 丢失少量数据 | 可立即恢复 |
>| 机器掉电，但是能立即恢复供电情况 | 不丢失       | 丢失少量数据 | 可立即恢复 |
>| 机器无法开机                     | 单点全部丢失 | 单点全部丢失 | 无法恢复   |
>| 磁盘设备损坏                     | 单点全部丢失 | 单点全部丢失 | 无法恢复   |
>
>可以看到如果是单点的部署架构，如果出现了严重的设备问题会导致整个rocketmq不可用，数据信息全部丢失。所以为了避免这种情况，推荐在部署集群方式上选择多Master多Slaver模式。RocketMq在异步复制的模式下，可以保证99%的消息不丢失，但是仍然会有极少量的消息可能会丢失，通过同步双写的话可以保证数据不丢失，但是势必会影响到性能，适合对消息可靠性要求级高的场合，例如与Money相关的应用。

#### 3. Broker的Buffer满了怎么办

>Broker的Buffer通常指的是Broker中一个队列的内存buffer大小，这类Buffer通常大小有限。但是在RocketMq中是没有内存Buffer这个概念的，RocketMq的队列都是持久化磁盘，数据定期清洗。
>
>Rocketmq的内存Buffer可以抽象理解成一个无限长度的队列，无论有多少数据都可以装得下，但是这个无限是有前提的，Broker会定期删除过期的数据，例如Broker只保存3天的消息，那么这个Buffer虽然长度无限，但是3天前的数据会被从队尾删除。

#### 4. RocketMq的持久化策略 

>可以参照RocketMq存储中关于异步刷盘跟同步刷盘的介绍

#### 5. RocketMq的消息堆积能力

消息中间件的主要功能是异步解耦，还有个重要功能是挡住前端的数据洪峰，保证后端系统的稳定性，这就要求消息中间件具有一定的消息堆积能力，消息堆积分以下两种情况：

1. 消息堆积在内存Buffer，一旦超过内存Buffer，可以根据一定的丢弃策略来丢弃消息，如CORBA Notification规范中描述。适合能容忍丢弃消息的业务，这种情况消息的堆积能力主要在于内存Buffer大小，而且消息堆积后，性能下降不会太大，因为内存中数据多少对于对外提供的访问能力影响有限。
2. 消息堆积到持久化存储系统中，例如DB，KV存储，文件记录形式。 当消息不能在内存Cache命中时，要不可避免的访问磁盘，会产生大量读IO，读IO的吞吐量直接决定了消息堆积后的访问能力。

评估消息堆积能力主要有以下四点：

1. 消息能堆积多少条，多少字节？即消息的堆积容量。
2. 消息堆积后，发消息的吞吐量大小，是否会受堆积影响？
3. 消息堆积后，正常消费的Consumer是否会受影响？
4. 消息堆积后，访问堆积在磁盘的消息时，吞吐量有多大？
>|                                      | 堆积性能指标                                     |
>| ------------------------------------ | ------------------------------------------------ |
>| 消息的堆积容量                       | 依赖磁盘大小                                     |
>| 发消息的吞吐量大小受影响程度         | 无SLAVE情况，会有一定影响, 有SLAVE情况，不受影响 |
>| 正常消费的Consumer是否会受影响       | 无SLAVE情况，会有一定影响, 有SLAVE情况，不受影响 |
>| 访问堆积在磁盘的消息时，吞吐量有多大 | 与访问的并发有关，最慢会降到5000左右             |

#### 6. RocketMq的高可用演练场景

| 项目                  | 发送消息   | 发送消息过程中     | 接收消费消息                      |
| --------------------- | ---------- | ------------------ | --------------------------------- |
| 停用一个namesrv       | 不影响通信 | 不影响通信         | 不影响通信                        |
| 停用全部namesrv       | 影响通信   | 不影响通信         | 影响通信，启动任意的namesrv可恢复 |
| 停用单个master broker | 不影响通信 | 不影响通信         | 不影响通信                        |
| 停用全部master broker | 影响通信   | 影响通信，无法恢复 | 影响通信                          |
| 停用一个slave broker  | 不影响通信 | 不影响通信         | 不影响通信                        |
| 停用全部slave broker  | 不影响通信 | 影响通信，无法恢复 | 影响通信，无法恢复                |

#### 7. RocketMq在发送消息的时候需要注意什么

>1. 一个应用尽可能用一个Topic，消息子类型用tags来标识，tags可以由应用自由设置。只有发送消息设置了tags，消费方在订阅消息时，才可以利用tags在broker做消息过滤。
>   message.setTags("TagA");
>2. 每个消息在业务层面的唯一标识码，要设置到keys字段，方便将来定位消息丢失问题。服务器会为每个消息创建索引（哈希索引），应用可以通过topic，key来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证key尽可能唯一，这样可以避免潜在的哈希冲突。
>3. 消息发送成功或者失败，要打印消息日志，务必要打印sendresult和key字段。
>4. send消息方法，只要不抛异常，就代表发送成功。但是发送成功会有多个状态，在sendResult里定义。

#### 8. 消息发送失败如何处理

>Producer的send方法本身支持内部重试，但是仍然不能保证消息一定发送成功，为保证消息一定成功，建议应用这样做：如果调用send同步方法发送失败，则尝试将消息存储到db，由后台线程定时重试，保证消息一定到达Broker。

#### 9. RocketMq在消费消息过程中需要注意什么

>RocketMQ无法避免消息重复，所以如果业务对消费重复非常敏感，务必要在业务层面去重，有以下几种去重方式:
>
>1. 将消息的唯一键，可以是msgId，也可以是消息内容中的唯一标识字段，例如订单Id等，消费之前判断是否在Db中存在，如果不存在则插入，并消费，否则跳过。（实际过程要考虑原子性问题，判断是否存在可以尝试插入，如果报主键冲突，则插入失败，直接跳过）, msgId一定是全局唯一标识符，但是可能会存在同样的消息有两个不同msgId的情况（有多种原因），这种情况可能会使业务上重复消费，建议最好使用消息内容中的唯一标识字段去重。
>2. 使用业务层面的状态机去重。



